<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ğŸš¦ 3D Traffic Simulator with Accidents & Emergency</title>
  <style>
    body { margin: 0; overflow: hidden; background: #1a1a1a; }
    canvas { display: block; }
    #infoBox {
      position: fixed;
      top: 10px; left: 10px;
      color: white;
      background: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 8px;
      font-family: sans-serif;
      max-width: 300px;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="infoBox">ğŸš¨ Traffic Simulator with accidents and emergency vehicles</div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // === Setup scene, camera, renderer ===
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x1a1a1a, 50, 120);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
    directionalLight.position.set(50, 100, 50);
    directionalLight.castShadow = true;
    scene.add(ambientLight, directionalLight);

    // Ground, roads, curbs and lines (simplified from your code)
    const groundGeometry = new THREE.PlaneGeometry(100, 100);
    const groundMaterial = new THREE.MeshStandardMaterial({color:0x222222});
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Roads
    const roadWidth = 40, roadLength = 100, roadHeight = 0.1;
    const roadMat = new THREE.MeshStandardMaterial({color:0x444444});
    const verticalRoad = new THREE.Mesh(new THREE.BoxGeometry(roadWidth, roadHeight, roadLength), roadMat);
    verticalRoad.position.set(0, 0.05, 0);
    verticalRoad.receiveShadow = true;
    scene.add(verticalRoad);
    const horizontalRoad = new THREE.Mesh(new THREE.BoxGeometry(roadLength, roadHeight, roadWidth), roadMat);
    horizontalRoad.position.set(0, 0.05, 0);
    horizontalRoad.receiveShadow = true;
    scene.add(horizontalRoad);

    // Curbs (simplified)
    const curbHeight = 0.5, curbThickness = 1;
    const curbMat = new THREE.MeshStandardMaterial({color: 0xffffff});
    const curbVerticalGeom = new THREE.BoxGeometry(curbThickness, curbHeight, roadLength + 4);
    const curbLeftVertical = new THREE.Mesh(curbVerticalGeom, curbMat);
    curbLeftVertical.position.set(-(roadWidth/2 + curbThickness/2), curbHeight/2, 0);
    curbLeftVertical.receiveShadow = true;
    scene.add(curbLeftVertical);
    const curbRightVertical = new THREE.Mesh(curbVerticalGeom, curbMat);
    curbRightVertical.position.set(roadWidth/2 + curbThickness/2, curbHeight/2, 0);
    curbRightVertical.receiveShadow = true;
    scene.add(curbRightVertical);
    const curbHorizontalGeom = new THREE.BoxGeometry(roadLength + 4, curbHeight, curbThickness);
    const curbTopHorizontal = new THREE.Mesh(curbHorizontalGeom, curbMat);
    curbTopHorizontal.position.set(0, curbHeight/2, -(roadWidth/2 + curbThickness/2));
    curbTopHorizontal.receiveShadow = true;
    scene.add(curbTopHorizontal);
    const curbBottomHorizontal = new THREE.Mesh(curbHorizontalGeom, curbMat);
    curbBottomHorizontal.position.set(0, curbHeight/2, roadWidth/2 + curbThickness/2);
    curbBottomHorizontal.receiveShadow = true;
    scene.add(curbBottomHorizontal);

    // Lines center
    const lineThickness = 0.5, lineLength = 10, lineHeight = 0.2;
    const lineColor = 0xffd800;
    const verticalLine = new THREE.Mesh(
      new THREE.BoxGeometry(lineThickness, lineHeight, lineLength),
      new THREE.MeshStandardMaterial({color: lineColor, emissive: lineColor})
    );
    verticalLine.position.set(0, lineHeight/2 + 0.11, 0);
    scene.add(verticalLine);
    const horizontalLine = new THREE.Mesh(
      new THREE.BoxGeometry(lineLength, lineHeight, lineThickness),
      new THREE.MeshStandardMaterial({color: lineColor, emissive: lineColor})
    );
    horizontalLine.position.set(0, lineHeight/2 + 0.11, 0);
    scene.add(horizontalLine);

    // Traffic Light class
    class TrafficLight {
      constructor(x, z, initialColor = 'red') {
        this.group = new THREE.Group();
        const poleGeom = new THREE.CylinderGeometry(0.3, 0.3, 5);
        const poleMat = new THREE.MeshStandardMaterial({color:0x222222});
        const pole = new THREE.Mesh(poleGeom, poleMat);
        pole.position.y = 2.5;
        this.group.add(pole);
        const boxGeom = new THREE.BoxGeometry(1, 2.5, 1);
        const boxMat = new THREE.MeshStandardMaterial({color:0x111111});
        const box = new THREE.Mesh(boxGeom, boxMat);
        box.position.y = 4.25;
        this.group.add(box);
        this.redLight = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshStandardMaterial({color:0x550000, emissive:0x000000}));
        this.redLight.position.set(0, 5.3, 0.45);
        this.group.add(this.redLight);
        this.yellowLight = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshStandardMaterial({color:0x555500, emissive:0x000000}));
        this.yellowLight.position.set(0, 4.7, 0.45);
        this.group.add(this.yellowLight);
        this.greenLight = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshStandardMaterial({color:0x005500, emissive:0x000000}));
        this.greenLight.position.set(0, 4.1, 0.45);
        this.group.add(this.greenLight);
        this.group.position.set(x, 0, z);
        scene.add(this.group);
        this.setColor(initialColor);
      }
      setColor(color) {
        this.redLight.material.emissive.set(0x000000);
        this.yellowLight.material.emissive.set(0x000000);
        this.greenLight.material.emissive.set(0x000000);
        switch(color) {
          case 'red': this.redLight.material.emissive.set(0xff0000); break;
          case 'yellow': this.yellowLight.material.emissive.set(0xffff00); break;
          case 'green': this.greenLight.material.emissive.set(0x00ff00); break;
        }
        this.currentColor = color;
      }
    }

    // Traffic Lights dictionary for NS and EW
    const trafficLights = {
      NS: [
        new TrafficLight(-(roadWidth/2 + curbThickness + 1), -(roadWidth/2 + curbThickness + 1), 'green'),
        new TrafficLight(-(roadWidth/2 + curbThickness + 1), (roadWidth/2 + curbThickness + 1), 'green'),
      ],
      EW: [
        new TrafficLight((roadWidth/2 + curbThickness + 1), -(roadWidth/2 + curbThickness + 1), 'red'),
        new TrafficLight((roadWidth/2 + curbThickness + 1), (roadWidth/2 + curbThickness + 1), 'red'),
      ]
    };

    // Colors for cars
    const carColors = [0xff0000, 0x2194ce, 0x00ff00, 0xffa500, 0x800080, 0xffff00];

    // Car class with collision detection
    class Car {
      constructor(x, z, dir) {
        this.group = new THREE.Group();

        // Random color
        const color = carColors[Math.floor(Math.random() * carColors.length)];

        const body = new THREE.Mesh(
          new THREE.BoxGeometry(2, 1, 4),
          new THREE.MeshStandardMaterial({color})
        );
        body.position.y = 0.5;

        const top = new THREE.Mesh(
          new THREE.BoxGeometry(1.5, 0.6, 2),
          new THREE.MeshStandardMaterial({color: 0xeeeeee})
        );
        top.position.set(0, 1, 0);

        this.group.add(body, top);

        this.group.position.set(x, 0.1, z);
        this.direction = dir;
        this.speed = 0.15;
        this.isStopped = false;
        this.isPenalized = false;

        // Rotation according to direction
        if(dir === 'NS') this.group.rotation.y = Math.PI;
        else if(dir === 'EW') this.group.rotation.y = -Math.PI/2;

        scene.add(this.group);
      }

      update(lightStatus) {
        if(this.isStopped) return; // Ø§Ú¯Ø± Ù…Ø§Ø´ÛŒÙ† Ù…ØªÙˆÙ‚Ù Ø´Ø¯Ù‡ Ø­Ø±Ú©Øª Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯

        if(lightStatus[this.direction] === 'green') {
          if(this.direction === 'NS') {
            this.group.position.z += this.speed;
            if(this.group.position.z > (roadLength/2 + 10)) this.group.position.z = -(roadLength/2 + 10);
          } else {
            this.group.position.x -= this.speed;
            if(this.group.position.x < -(roadLength/2 + 10)) this.group.position.x = (roadLength/2 + 10);
          }
        }
      }

      distanceTo(otherCar) {
        const pos1 = this.group.position;
        const pos2 = otherCar.group.position;
        return pos1.distanceTo(pos2);
      }

      stop() {
        this.isStopped = true;
      }
      start() {
        this.isStopped = false;
      }
      penalize() {
        this.isPenalized = true;
        // ØªØºÛŒÛŒØ± Ø±Ù†Ú¯ Ø¨Ù‡ Ù‚Ø±Ù…Ø² ØªÛŒØ±Ù‡ Ø¨Ø±Ø§ÛŒ Ù†Ø´Ø§Ù† Ø¯Ø§Ø¯Ù† Ø¬Ø±ÛŒÙ…Ù‡
        this.group.children[0].material.color.set(0x8b0000);
      }
      resetPenalty() {
        this.isPenalized = false;
        this.group.children[0].material.color.set(0xff0000);
      }
    }

    // Ø³Ø§Ø¯Ù‡â€ŒØªØ±ÛŒÙ† Ù…Ø¯Ù„ Ø§Ù†Ø³Ø§Ù† Ù¾Ø±Øª Ø´Ø¯Ù‡ (ÛŒÚ© Ú©Ø±Ù‡ Ø³Ø± Ùˆ Ù…Ú©Ø¹Ø¨ Ø¨Ø¯Ù†)
    class Human {
      constructor(position) {
        this.group = new THREE.Group();

        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.3),
          new THREE.MeshStandardMaterial({color:0xffccaa})
        );
        head.position.set(0, 1.6, 0);
        const body = new THREE.Mesh(
          new THREE.BoxGeometry(0.7, 1, 0.4),
          new THREE.MeshStandardMaterial({color:0xffccaa})
        );
        body.position.set(0, 0.8, 0);
        this.group.add(head, body);

        this.group.position.copy(position);
        scene.add(this.group);

        this.fallen = false;
        this.speed = 0.02;
      }

      update() {
        if(!this.fallen) {
          this.group.position.y -= 0.05;
          if(this.group.position.y < 0.5) {
            this.fallen = true;
          }
        } else {
          // Ø¨Ø¹Ø¯ Ø§Ø² Ø³Ù‚ÙˆØ· Ø­Ø±Ú©Øª Ø¨Ù‡ Ø³Ù…Øª Ø¢Ù…Ø¨ÙˆÙ„Ø§Ù†Ø³
          if(ambulance) {
            const dir = new THREE.Vector3().subVectors(ambulance.group.position, this.group.position).normalize();
            this.group.position.add(dir.multiplyScalar(this.speed));
            if(this.group.position.distanceTo(ambulance.group.position) < 1) {
              // Ø±Ø³ÛŒØ¯Ù† Ø¨Ù‡ Ø¢Ù…Ø¨ÙˆÙ„Ø§Ù†Ø³ = Ø­Ø°Ù Ø§Ù†Ø³Ø§Ù† Ø§Ø² ØµØ­Ù†Ù‡
              scene.remove(this.group);
              humanInjured = null;
              ambulance.pickupDone = true;
            }
          }
        }
      }
    }

    // Ù…Ø§Ø´ÛŒÙ† Ù¾Ù„ÛŒØ³
    class PoliceCar extends Car {
      constructor(x, z, dir) {
        super(x, z, dir);
        this.group.children[0].material.color.set(0x0000ff);
        this.speed = 0.2;
        this.isOnDuty = false;
        this.targetCar = null;
      }

      // Ø­Ø±Ú©Øª Ø¨Ù‡ Ø³Ù…Øª Ù…Ø§Ø´ÛŒÙ† Ù…ØªØ®Ù„Ù
      chase(target) {
        this.isOnDuty = true;
        this.targetCar = target;
      }

      update() {
        if(!this.isOnDuty) return;
        if(!this.targetCar) return;

        // Ø¬Ù‡Øª Ø­Ø±Ú©Øª Ø¨Ù‡ Ø³Ù…Øª Ù…Ø§Ø´ÛŒÙ† Ù…ØªØ®Ù„Ù
        const targetPos = this.targetCar.group.position.clone();
        const currentPos = this.group.position.clone();
        const dirVec = new THREE.Vector3().subVectors(targetPos, currentPos);
        const dist = dirVec.length();
        if(dist > 1) {
          dirVec.normalize();
          this.group.position.add(dirVec.multiplyScalar(this.speed));
        } else {
          // Ø±Ø³ÛŒØ¯Ù† Ø¨Ù‡ Ù…Ø§Ø´ÛŒÙ† Ù…ØªØ®Ù„ÙØŒ Ù…Ø§Ø´ÛŒÙ† Ø±Ø§ Ø¬Ø±ÛŒÙ…Ù‡ Ùˆ Ù…ÛŒâ€ŒØ¨Ø±Ø¯ (Ù…Ø§Ø´ÛŒÙ† Ù…ØªÙˆÙ‚Ù Ù…ÛŒâ€ŒØ´ÙˆØ¯)
          this.targetCar.stop();
          this.targetCar.penalize();

          // Ù¾Ù„ÛŒØ³ Ø¨Ø¹Ø¯ Ø§Ø² Ù…Ø¯ØªÛŒ Ù…Ø§Ø´ÛŒÙ† Ø±Ø§ "Ù…ÛŒâ€ŒØ¨Ø±Ø¯" (Ù…Ø§Ø´ÛŒÙ† Ø±Ø§ Ø­Ø°Ù Ù…ÛŒâ€ŒÚ©Ù†Ø¯)
          setTimeout(() => {
            scene.remove(this.targetCar.group);
            cars = cars.filter(c => c !== this.targetCar);
            this.isOnDuty = false;
            this.targetCar = null;
            // Ù¾Ø§ÛŒØ§Ù† ØªØµØ§Ø¯ÙØŒ ØªØ±Ø§ÙÛŒÚ© Ø³Ø¨Ú©â€ŒØªØ± Ù…ÛŒâ€ŒØ´ÙˆØ¯
            trafficJam = false;
          }, 8000);
        }
      }
    }

    // Ø¢Ù…Ø¨ÙˆÙ„Ø§Ù†Ø³ (Ù…Ø´Ø§Ø¨Ù‡ Ù…Ø§Ø´ÛŒÙ† Ø¨Ø§ Ø±Ù†Ú¯ Ø®Ø§Øµ)
    class Ambulance extends Car {
      constructor(x, z, dir) {
        super(x, z, dir);
        this.group.children[0].material.color.set(0xffffff);
        this.speed = 0.25;
        this.pickupDone = false;
        this.isOnDuty = false;
      }

      // Ø­Ø±Ú©Øª Ø¨Ù‡ Ù…Ø­Ù„ Ø§Ù†Ø³Ø§Ù† Ø¢Ø³ÛŒØ¨ Ø¯ÛŒØ¯Ù‡
      rescue(human) {
        this.isOnDuty = true;
        this.targetHuman = human;
      }

      update() {
        if(!this.isOnDuty) return;

        if(this.targetHuman) {
          const targetPos = this.targetHuman.group.position.clone();
          const currentPos = this.group.position.clone();
          const dirVec = new THREE.Vector3().subVectors(targetPos, currentPos);
          const dist = dirVec.length();
          if(dist > 1) {
            dirVec.normalize();
            this.group.position.add(dirVec.multiplyScalar(this.speed));
          } else {
            // Ø±Ø³ÛŒØ¯Ù† Ø¨Ù‡ Ø§Ù†Ø³Ø§Ù†
            this.pickupDone = true;
            this.isOnDuty = false;
            this.targetHuman = null;
          }
        }
      }
    }

    // Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ø´Ø¨ÛŒÙ‡ Ø³Ø§Ø²ÛŒ
    let cars = [];
    let policeCar = null;
    let ambulance = null;
    let humanInjured = null;
    let trafficJam = false;

   // ÙˆØ¶Ø¹ÛŒØª Ú†Ø±Ø§Øº Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒÛŒ
    const greenDuration = 10000; // 10 Ø«Ø§Ù†ÛŒÙ‡
    let lastSwitch = Date.now();
    let currentLight = 'NS';

    function updateTrafficLights() {
      if(Date.now() - lastSwitch > greenDuration) {
        currentLight = currentLight === 'NS' ? 'EW' : 'NS';
        lastSwitch = Date.now();

        if(currentLight === 'NS') {
          trafficLights.NS.forEach(l => l.setColor('green'));
          trafficLights.EW.forEach(l => l.setColor('red'));
        } else {
          trafficLights.NS.forEach(l => l.setColor('red'));
          trafficLights.EW.forEach(l => l.setColor('green'));
        }
      }
    }

    // Ù†Ù…Ø§ÛŒØ´ Ø²Ù…Ø§Ù† Ø¨Ø§Ù‚ÛŒ Ù…Ø§Ù†Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ú†Ø±Ø§Øº Ø³Ø¨Ø²
    const timerDisplay = document.getElementById('timerDisplay');
    function updateTimerDisplay() {
      const elapsed = Date.now() - lastSwitch;
      const timeLeft = Math.max(0, Math.ceil((greenDuration - elapsed)/1000));
      timerDisplay.textContent = `Time Left: ${timeLeft} s`;
    }

    // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ù…Ø§Ø´ÛŒÙ†â€ŒÙ‡Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø§ÙˆÙ„ÛŒÙ‡ (Ø¨Ø§ ØªÙ†ÙˆØ¹ Ø¨ÛŒØ´ØªØ±)
    function addRandomCars(num) {
      for(let i=0; i<num; i++) {
        const dirs = ['NS', 'EW'];
        const dir = dirs[Math.floor(Math.random()*dirs.length)];
        let x, z;
        if(dir === 'NS') {
          x = -10 + Math.random()*20; // Ú©Ù…ÛŒ Ù¾Ø±Ø§Ú©Ù†Ø¯Ú¯ÛŒ Ø¹Ø±Ø¶ÛŒ
          z = -roadLength/2 - Math.random()*40;
        } else {
          x = roadLength/2 + Math.random()*40;
          z = -10 + Math.random()*20;
        }
        cars.push(new Car(x, z, dir));
      }
    }

    addRandomCars(20);

    // ØªØ§Ø¨Ø¹ ØªØ´Ø®ÛŒØµ Ø¨Ø±Ø®ÙˆØ±Ø¯ Ø³Ø§Ø¯Ù‡ (ÙØ§ØµÙ„Ù‡ Ú©Ù…ØªØ± Ø§Ø² 3 Ù…ØªØ±)
    function checkCollisions() {
      for(let i=0; i<cars.length; i++) {
        for(let j=i+1; j<cars.length; j++) {
          if(cars[i].distanceTo(cars[j]) < 3) {
            return [cars[i], cars[j]];
          }
        }
      }
      return null;
    }

    // Ø³Ù†Ø§Ø±ÛŒÙˆ Ø¨Ø±Ø®ÙˆØ±Ø¯
    function handleAccident(car1, car2) {
      if(trafficJam) return; // Ø§Ú¯Ø± ØªØ±Ø§ÙÛŒÚ© ÙØ¹Ø§Ù„ Ø§Ø³ØªØŒ Ø¨Ø±Ø®ÙˆØ±Ø¯ Ø¨Ø¹Ø¯ÛŒ Ù†Ú¯ÛŒØ±ÛŒÙ…

      trafficJam = true;
      document.getElementById('infoBox').innerHTML = "ğŸš¨ Accident! Police and ambulance dispatched.";

      // Ù…Ø§Ø´ÛŒÙ† Ù¾Ù„ÛŒØ³ Ø¨Ø³Ø§Ø² Ø§Ú¯Ø± Ù†ÛŒØ³Øª
      if(!policeCar) policeCar = new PoliceCar(roadLength/2 + 10, 0, 'EW');
      if(!ambulance) ambulance = new Ambulance(-roadLength/2 - 10, 0, 'EW');

      // ÛŒÚ©ÛŒ Ø§Ø² Ø¯Ùˆ Ù…Ø§Ø´ÛŒÙ† Ø±Ø§ Ù…Ù‚ØµØ± ÙØ±Ø¶ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
      const culprit = Math.random() < 0.5 ? car1 : car2;
      culprit.stop();

      // Ù…Ø§Ø´ÛŒÙ† Ù¾Ù„ÛŒØ³ Ø¨Ù‡ Ø³Ù…Øª Ù…Ø§Ø´ÛŒÙ† Ù…Ù‚ØµØ± Ø­Ø±Ú©Øª Ú©Ù†Ø¯ Ùˆ Ø¬Ø±ÛŒÙ…Ù‡ Ú©Ù†Ø¯
      policeCar.chase(culprit);

      // Ù¾Ø±Øª Ø´Ø¯Ù† Ø§Ù†Ø³Ø§Ù† Ø§Ø² Ù…Ø§Ø´ÛŒÙ† Ù…Ù‚ØµØ±
      humanInjured = new Human(culprit.group.position.clone().add(new THREE.Vector3(0, 1, 0)));

      // Ø¢Ù…Ø¨ÙˆÙ„Ø§Ù†Ø³ Ø¨Ø±Ø§ÛŒ Ù†Ø¬Ø§Øª Ø§Ù†Ø³Ø§Ù† Ø¨Ù‡ Ù…Ø­Ù„ Ø­Ø±Ú©Øª Ú©Ù†Ø¯
      ambulance.rescue(humanInjured);

      // Ø¨Ø¹Ø¯ Ø§Ø² Ù†Ø¬Ø§Øª Ùˆ Ø¬Ø±ÛŒÙ…Ù‡ØŒ ØªØ±Ø§ÙÛŒÚ© Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø¹Ø§Ø¯ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯ (Ø¯Ø± updatePoliceCar Ø¨Ø¹Ø¯ Ø§Ø² Ø¬Ø±ÛŒÙ…Ù‡ Ú©Ø§Ù…Ù„)
    }

    // Main animation loop
    function animate() {
      requestAnimationFrame(animate);
      updateTrafficLights();

      // Ø­Ø±Ú©Øª Ù…Ø§Ø´ÛŒÙ†â€ŒÙ‡Ø§ Ø§Ú¯Ø± ØªØ±Ø§ÙÛŒÚ© Ù†ÛŒØ³Øª ÛŒØ§ ØªØ±Ø§ÙÛŒÚ© Ø§Ù…Ø§ Ù…Ø§Ø´ÛŒÙ† Ù…ØªÙˆÙ‚Ù Ù†ÛŒØ³Øª
      cars.forEach(car => {
        if(!trafficJam || (trafficJam && car.isStopped === false)) {
          car.update({
            NS: currentLight === 'NS' ? 'green' : 'red',
            EW: currentLight === 'EW' ? 'green' : 'red',
          });
        }
      });

      // Ø¢Ù¾Ø¯ÛŒØª Ù…Ø§Ø´ÛŒÙ† Ù¾Ù„ÛŒØ³
      if(policeCar) policeCar.update();

      // Ø¢Ù¾Ø¯ÛŒØª Ø¢Ù…Ø¨ÙˆÙ„Ø§Ù†Ø³
      if(ambulance) ambulance.update();

      // Ø¢Ù¾Ø¯ÛŒØª Ø§Ù†Ø³Ø§Ù† Ù¾Ø±Øª Ø´Ø¯Ù‡
      if(humanInjured) humanInjured.update();

      // Ú†Ú© Ø¨Ø±Ø®ÙˆØ±Ø¯Ù‡Ø§ ÙÙ‚Ø· ÙˆÙ‚ØªÛŒ ØªØ±Ø§ÙÛŒÚ© Ù†ÛŒØ³Øª (Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø§ÛŒØ¬Ø§Ø¯ Ø¨Ø±Ø®ÙˆØ±Ø¯Ù‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø¯Ø± ØªØ±Ø§ÙÛŒÚ©)
      if(!trafficJam) {
        const collision = checkCollisions();
        if(collision) {
          handleAccident(collision[0], collision[1]);
        }
      }

      renderer.render(scene, camera);
    }

    // Ø¯ÙˆØ±Ø¨ÛŒÙ† Ùˆ Ú©Ù†ØªØ±Ù„
    camera.position.set(0, 50, 70);

    camera.lookAt(0, 0, 0);

    animate();

    
    window.addEventListener('resize', () => {
        
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
